package py01compiladores;
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;

    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

/* define how to connect to the scanner! */
//init with {: s.init(); :};
//scan with {: return s.next_token(); :};
init with {::};
scan with {:return lex.next_token();:};


/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, PLUSP, MINUS, MINUSM, DIV, POT, MOD, TIMES, UMINUS, LPAREN, RPAREN, INTEGER_LITERAL;
terminal Integer    NUMBER;        // our scanner provides numbers as integers
terminal            IDENTIFIER, STRING_LITERAL, EQEQ, BREAK, BOOLEAN, ABSTRACT, EQ, DOT;
terminal            GREATERT, LOWERT, GREATERE, LOWERE, NOT, NOTEQUALS, CONJUNTION, DISJUNTION, SEP;
terminal            FLOTANTE, ENTERO, INT, FLOAT, CHAR, CHARC, STRING, ARRAY;
terminal            TRUE,FALSE;
terminal            IF, ELSE, WHILE, FOR, IN, RANGE, SWICH, CASE;
terminal            GLOB, LOC, RETURN, PRINTF, FUNC, MAIN, PARAM, READ, DEFAULT;
terminal            PARENTA, PARENTC, PARENTCA, PARENTCC, UNDERS;
terminal            ENDLINE;
terminal            SEMICOLON;

/* Non-terminals */
non terminal expr_list;
non terminal Integer expr; // used to store evaluated subexpressions
non terminal String PROGRAMA, BODY, LINE, STATEMENT, E;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left DIV;
precedence left UMINUS;

/* The grammar rules */
start with PROGRAMA;

PROGRAMA  ::= BODY;

BODY      ::= BODY LINE:l SEMI {: System.out.println(l);:}
            | LINE:l SEMI {: System.out.println(l);:};

LINE      ::= STATEMENT | E;

STATEMENT ::= IDENTIFIER EQ INTEGER_LITERAL;

E      ::= E PLUS E 
         | E MINUS E 
         | E TIMES E 
         | E DIV E 
         | INTEGER_LITERAL ;

